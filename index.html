<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="美丽总是那么短暂" />
  

  
  
  
  
  
  
  <title>风士魁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="美丽总是那么短暂">
<meta property="og:type" content="website">
<meta property="og:title" content="风士魁">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="风士魁">
<meta property="og:description" content="美丽总是那么短暂">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风士魁">
<meta name="twitter:description" content="美丽总是那么短暂">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="风士魁" rel="home">风士魁</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">走的太快容易孤独，快跟上我的步伐！！！</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-ios视频直播开发" class="post-ios视频直播开发 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2016/06/12/ios视频直播开发/">ios视频直播开发</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/06/12/ios视频直播开发/" data-id="cipc8c2dh0004hxs6fqqkejvy" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<ol>
<li>采集硬件（摄像头）视频图像</li>
</ol>
<p>iOS 的摄像头采集。</p>
<p>首先初始化AVCaptureSession，说到Session，有没有人想到AVAudioSession呢？</p>
<p>// 初始化 AVCaptureSession<br>_session = [[AVCaptureSession alloc] init];<br>设置采集的 Video 和 Audio 格式，这两个是分开设置的，也就是说，你可以只采集视频。<br>/ 配置采集输入源（摄像头）<br>NSError <em>error = nil;<br>// 获得一个采集设备，例如前置/后置摄像头<br>AVCaptureDevice </em>videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];<br>// 用设备初始化一个采集的输入对象<br>AVCaptureDeviceInput *videoInput = [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&amp;error];<br>if (error) {<br>NSLog(@”Error getting video input device: %@”, error.description);<br>}<br>if ([_session canAddInput:videoInput]) {<br>[_session addInput:videoInput]; // 添加到Session<br>}</p>
<p>// 配置采集输出，即我们取得视频图像的接口<br>_videoQueue = dispatch_queue_create(“Video Capture Queue”, DISPATCH_QUEUE_SERIAL);<br>_videoOutput = [[AVCaptureVideoDataOutput alloc] init];<br>[_videoOutput setSampleBufferDelegate:self queue:_videoQueue];</p>
<p>// 配置输出视频图像格式<br>NSDictionary <em>captureSettings = @{(NSString</em>)kCVPixelBufferPixelFormatTypeKey: @(kCVPixelFormatType_32BGRA)};</p>
<p>_videoOutput.videoSettings = captureSettings;<br>_videoOutput.alwaysDiscardsLateVideoFrames = YES;<br>if ([_session canAddOutput:_videoOutput]) {<br>[_session addOutput:_videoOutput];  // 添加到Session<br>}</p>
<p>// 保存Connection，用于在SampleBufferDelegate中判断数据来源（是Video/Audio？）<br>_videoConnection = [_videoOutput connectionWithMediaType:AVMediaTypeVideo];<br>实现 AVCaptureOutputDelegate：</p>
<ul>
<li>(void) captureOutput:(AVCaptureOutput <em>)captureOutput<br>didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer<br>fromConnection:(AVCaptureConnection </em>)connection<br>{<br>// 这里的sampleBuffer就是采集到的数据了，但它是Video还是Audio的数据，得根据connection来判断<br>if (connection == _videoConnection) {  // Video<br>/<em><br>// 取得当前视频尺寸信息<br>CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);<br>int width = CVPixelBufferGetWidth(pixelBuffer);<br>int height = CVPixelBufferGetHeight(pixelBuffer);<br>NSLog(@”video width: %d  height: %d”, width, height);
</em>/<br>NSLog(@”在这里获得video sampleBuffer，做进一步处理（编码H.264）”);<br>} else if (connection == _audioConnection) {  // Audio<br>NSLog(@”这里获得audio sampleBuffer，做进一步处理（编码AAC）”);<br>}<br>}<br>关于实时编码H.264和AAC Buffer，这里又是两个技术点，之后再讲吧。</li>
</ul>
<p>配置完成，现在启动 Session：<br>// 启动 Session<br>[_session startRunning];<br>1.1 附加任务：将当前硬件采集视频图像显示到屏幕</p>
<p>很简单，发送端直接使用自家的AVCaptureVideoPreviewLayer显示，so easy<br>_previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:_session];<br>_previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; // 设置预览时的视频缩放方式<br>[[_previewLayer connection] setVideoOrientation:AVCaptureVideoOrientationPortrait]; // 设置视频的朝向</p>
<p>_previewLayer.frame = self.view.layer.bounds;<br>[self.view.layer addSublayer:_previewLayer];<br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/06/12/ios视频直播开发/">
    <time datetime="2016-06-12T05:45:08.000Z" class="entry-date">
        2016-06-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-ios毛玻璃的实现" class="post-ios毛玻璃的实现 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2016/05/25/ios毛玻璃的实现/">ios毛玻璃的实现</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/05/25/ios毛玻璃的实现/" data-id="cipc8c2df0003hxs69i1mh4ee" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span>其实在iOS7.0(包括)之前还是有系统的类可以实现毛玻璃效果的, 就是 UIToolbar这个类,并且使用相当简单,几行代码就可以搞定.</span></p>
<p>下面是代码实现:</p>
<p>创建一个UIToolbar实例,设置它的frame或者也可以通过添加约束</p>
<p>然后UIToolbar有一个属性:barStyle,设置对应的枚举值来呈现 毛玻璃的样式,最后再添加到需要进行毛玻璃效果的view上即可.<br>1 /<em><br>2      毛玻璃的样式(枚举)<br>3      UIBarStyleDefault          = 0,<br>4      UIBarStyleBlack            = 1,<br>5      UIBarStyleBlackOpaque      = 1, // Deprecated. Use UIBarStyleBlack<br>6      UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES<br>7     </em>/<br>8     UIImageView <em>bgImgView = [[UIImageView alloc] initWithFrame:self.view.bounds];<br>9     bgImgView.image = [UIImage imageNamed:@”huoying4.jpg”];<br>10     [self.view addSubview:bgImgView];<br>11<br>12     UIToolbar </em>toolbar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 0, bgImgView.frame.size.width*0.5, bgImgView.frame.size.height)];<br>13     toolbar.barStyle = UIBarStyleBlackTranslucent;<br>14     [bgImgView addSubview:toolbar];</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/05/25/ios毛玻璃的实现/">
    <time datetime="2016-05-25T03:04:37.000Z" class="entry-date">
        2016-05-25
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-音频直播的难点总结" class="post-音频直播的难点总结 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2016/05/25/音频直播的难点总结/">音频直播的难点总结</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/05/25/音频直播的难点总结/" data-id="cipc8c2e0000ahxs66rddqx6o" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p></p><h1>音频直播的难点总结</h1><p></p>
<p>链接】ios多音频混合<br><a href="http://blog.csdn.net/zengconggen/article/details/7842076" target="_blank" rel="external">http://blog.csdn.net/zengconggen/article/details/7842076</a><br>李居豪  10:19:07<br>【链接】音频框架TheAmazingAudioEngine实现音效<br><a href="http://www.cocoachina.com/ios/20160201/15176.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160201/15176.html</a><br>李居豪  10:19:18<br><a href="https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine" target="_blank" rel="external">https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine</a><br>李居豪  10:19:34<br>【链接】ios视频和音频的合成<br><a href="http://www.tuicool.com/articles/bQzEr23" target="_blank" rel="external">http://www.tuicool.com/articles/bQzEr23</a></p>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/05/25/音频直播的难点总结/">
    <time datetime="2016-05-25T02:10:53.000Z" class="entry-date">
        2016-05-25
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-iosd多线程－－死锁" class="post-iosd多线程－－死锁 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/12/12/iosd多线程－－死锁/">iosd多线程－－死锁</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/12/12/iosd多线程－－死锁/" data-id="cipc8c2dd0002hxs67qh8953i" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>iOS有三种多线程编程的技术，分别是：<br>（一）NSThread<br>（二）Cocoa NSOperation<br>（三）GCD（全称：Grand Central Dispatch）</span></p>
<p>如果你对多线程开发还没有基本的了解,建议你看下面两篇博客</p>
<p><a href="http://www.cnblogs.com/kenshincui/p/3983982.html" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/3983982.html</a></p>
<p><a href="http://blog.jobbole.com/69019/" target="_blank" rel="external">http://blog.jobbole.com/69019/</a></p>
<p>这里就不对基本概念及应用做过多的赘述了,用下面五个案例为大家进阶多线程开发.</p>
<p>串行与并行<br>在使用GCD的时候，我们会把需要处理的任务放到Block中，然后将任务追加到相应的队列里面，这个队列，叫做Dispatch Queue。然而，存在于两种Dispatch Queue，一种是要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列。这两种，均遵循FIFO原则。</p>
<p>举一个简单的例子，在三个任务中输出1、2、3，串行队列输出是有序的1、2、3，但是并行队列的先后顺序就不一定了。</p>
<p>那么，并行队列又是怎么在执行呢？</p>
<p>虽然可以同时多个任务的处理，但是并行队列的处理量，还是要根据当前系统状态来。如果当前系统状态最多处理2个任务，那么1、2会排在前面，3什么时候操作，就看1或者2谁先完成，然后3接在后面。</p>
<p>串行和并行就简单说到这里，关于它们的技术点其实还有很多，可以自行了解。</p>
<p>同步与异步<br>串行与并行针对的是队列，而同步与异步，针对的则是线程。最大的区别在于，同步线程要阻塞当前线程，必须要等待同步线程中的任务执行完，返回以后，才能继续执行下一任务；而异步线程则是不用等待。</p>
<p>仅凭这几句话还是很难理解，所以之后准备了很多案例，可以边分析边理解。</p>
<p>GCD API<br>GCD API很多，这里仅介绍本文用到的。</p>
<ol>
<li>系统标准提供的两个队列</li>
</ol>
<p>// 全局队列，也是一个并行队列<br>dispatch_get_global_queue<br>// 主队列，在主线程中运行，因为主线程只有一个，所以这是一个串行队列<br>dispatch_get_main_queue</p>
<ol>
<li>除此之外，还可以自己生成队列</li>
</ol>
<p>// 从DISPATCH_QUEUE_SERIAL看出，这是串行队列<br>dispatch_queue_create(“com.demo.serialQueue”, DISPATCH_QUEUE_SERIAL)<br>// 同理，这是一个并行队列<br>dispatch_queue_create(“com.demo.concurrentQueue”, DISPATCH_QUEUE_CONCURRENT)</p>
<p>接下来是同步与异步线程的创建：</p>
<p>dispatch_sync(…, ^(block)) // 同步线程<br>dispatch_async(…, ^(block)) // 异步线程<br>案例与分析<br>假设你已经基本了解了上面提到的知识，接下来进入案例讲解阶段。</p>
<p>案例一：<br>NSLog(@”1”); // 任务1<br>dispatch_sync(dispatch_get_main_queue(), ^{<br>NSLog(@”2”); // 任务2<br>});<br>NSLog(@”3”); // 任务3</p>
<p>结果，控制台输出：</p>
<p>1</p>
<p>分析：</p>
<p>dispatch_sync表示是一个同步线程；<br>dispatch_get_main_queue表示运行在主线程中的主队列；<br>任务2是同步线程的任务。<br>首先执行任务1，这是肯定没问题的，只是接下来，程序遇到了同步线程，那么它会进入等待，等待任务2执行完，然后执行任务3。但这是队列，有任务来，当然会将任务加到队尾，然后遵循FIFO原则执行任务。那么，现在任务2就会被加到最后，任务3排在了任务2前面，问题来了：</p>
<p>任务3要等任务2执行完才能执行，任务2由排在任务3后面，意味着任务2要在任务3执行完才能执行，所以他们进入了互相等待的局面。【既然这样，那干脆就卡在这里吧】这就是死锁。</p>
<p>案例二：<br>NSLog(@”1”); // 任务1<br>dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{<br>NSLog(@”2”); // 任务2<br>});<br>NSLog(@”3”); // 任务3</p>
<p>结果，控制台输出：</p>
<p>1<br>2<br>3</p>
<p>分析：</p>
<p>首先执行任务1，接下来会遇到一个同步线程，程序会进入等待。等待任务2执行完成以后，才能继续执行任务3。从dispatch_get_global_queue可以看出，任务2被加入到了全局的并行队列中，当并行队列执行完任务2以后，返回到主队列，继续执行任务3。</p>
<p>案例三：<br>dispatch_queue_t queue = dispatch_queue_create(“com.demo.serialQueue”, DISPATCH_QUEUE_SERIAL);<br>NSLog(@”1”); // 任务1<br>dispatch_async(queue, ^{<br>NSLog(@”2”); // 任务2<br>dispatch_sync(queue, ^{<br>NSLog(@”3”); // 任务3<br>});<br>NSLog(@”4”); // 任务4<br>});<br>NSLog(@”5”); // 任务5</p>
<p>结果，控制台输出：</p>
<p>1<br>5<br>2<br>//5和2的顺序不一定</p>
<p>分析：</p>
<p>这个案例没有使用系统提供的串行或并行队列，而是自己通过dispatch_queue_create函数创建了一个DISPATCH_QUEUE_SERIAL的串行队列。</p>
<p>执行任务1；<br>遇到异步线程，将【任务2、同步线程、任务4】加入串行队列中。因为是异步线程，所以在主线程中的任务5不必等待异步线程中的所有任务完成；<br>因为任务5不必等待，所以2和5的输出顺序不能确定；<br>任务2执行完以后，遇到同步线程，这时，将任务3加入串行队列；<br>又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行。但是任务3所在的同步线程会阻塞，所以任务4必须等任务3执行完以后再执行。这就又陷入了无限的等待中，造成死锁。</p>
<p>案例四：<br>NSLog(@”1”); // 任务1<br>dispatch_async(dispatch_get_global_queue(0, 0), ^{<br>NSLog(@”2”); // 任务2<br>dispatch_sync(dispatch_get_main_queue(), ^{<br>NSLog(@”3”); // 任务3<br>});<br>NSLog(@”4”); // 任务4<br>});<br>NSLog(@”5”); // 任务5</p>
<p>结果，控制台输出：</p>
<p>1<br>2<br>5<br>3<br>4<br>//5和2的顺序不一定</p>
<p>分析：</p>
<p>首先，将【任务1、异步线程、任务5】加入Main Queue中，异步线程中的任务是：【任务2、同步线程、任务4】。</p>
<p>所以，先执行任务1，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。</p>
<p>然后再看异步线程中的任务执行顺序。任务2执行完以后，遇到同步线程。将同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。</p>
<p>当任务3执行完以后，没有了阻塞，程序继续执行任务4。</p>
<p>从以上的分析来看，得到的几个结果：1最先执行；2和5顺序不一定；4一定在3后面。</p>
<p>案例五：<br>dispatch_async(dispatch_get_global_queue(0, 0), ^{<br>NSLog(@”1”); // 任务1<br>dispatch_sync(dispatch_get_main_queue(), ^{<br>NSLog(@”2”); // 任务2<br>});<br>NSLog(@”3”); // 任务3<br>});<br>NSLog(@”4”); // 任务4<br>while (1) {<br>}<br>NSLog(@”5”); // 任务5</p>
<p>结果,控制台输出:<br>1<br>4<br>//1和4的顺序不一定</p>
<p>分析：</p>
<p>和上面几个案例的分析类似，先来看看都有哪些任务加入了Main Queue：【异步线程、任务4、死循环、任务5】。</p>
<p>在加入到Global Queue异步线程中的任务有：【任务1、同步线程、任务3】。</p>
<p>第一个就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。</p>
<p>任务4完成后，程序进入死循环，Main Queue阻塞。但是加入到Global Queue的异步线程不受影响，继续执行任务1后面的同步线程。</p>
<p>同步线程中，将任务2加入到了主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程，已经被死循环阻塞了。所以任务2无法执行，当然任务3也无法执行，在死循环后的任务5也不会执行。</p>
<p>最终，只能得到1和4顺序不定的结果。</p>
<p>如果你对多线程开发有了一定的了解,相信所有人都会跟你说GCD是最强大的,但是正如没有什么东西或者人是完美的,GCD也有它完成不了的工作,如果你正在做下载相关的开发,也许你会发现,GCD无法取消任务,你还是要用NSOperationQueue,建议你看下面这篇博客</p>
<p><a href="http://www.jianshu.com/p/fe1fec3d198f?plg_nld=1&amp;utm_source=QQ&amp;utm_content=note&amp;plg_auth=1&amp;utm_campaign=hugo&amp;plg_dev=1&amp;utm_medium=reader_share&amp;plg_nld=1&amp;plg_uin=1&amp;plg_usr=1&amp;plg_vkey=1" target="_blank" rel="external">http://www.jianshu.com/p/fe1fec3d198f?plg_nld=1&amp;utm_source=QQ&amp;utm_content=note&amp;plg_auth=1&amp;utm_campaign=hugo&amp;plg_dev=1&amp;utm_medium=reader_share&amp;plg_nld=1&amp;plg_uin=1&amp;plg_usr=1&amp;plg_vkey=1</a><br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/12/12/iosd多线程－－死锁/">
    <time datetime="2015-12-12T06:16:02.000Z" class="entry-date">
        2015-12-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-单例模式解读" class="post-单例模式解读 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/10/12/单例模式解读/">单例模式解读</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/10/12/单例模式解读/" data-id="cipc8c2dq0007hxs6cun59fk2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>IOS 中单例设计模式的解读与用法<br>一、单例的作用<br>二、单例的写法<br>方式1、不考虑线程<br>方式2、考虑线程安全<br>三、代码的优化<br>IOS 中单例设计模式的解读与用法</span></p>
<p>一、单例的作用</p>
<p>顾名思义，单例，即是在整个项目中，这个类的对象只能被初始化一次。它的这种特性，可以广泛应用于某些需要全局共享的资源中，比如管理类，引擎类，也可以通过单例来实现传值。UIApplication、NSUserDefaults等都是IOS中的系统单例。</p>
<p>二、单例的写法</p>
<p>单例的写法常用的有两种方式：</p>
<p>方式1、不考虑线程</p>
<p>static SingleCase *manager = nil;  </p>
<ul>
<li><p>(SingleCase *)defaultManager {<br>if (!manager){<br>SingleCase = [[self alloc] init];<br>return manager;<br>}<br>}<br>方式2、考虑线程安全</p>
</li>
<li><p>(SingleCase <em>)sharedManager<br>{<br>static SingleCase </em>ManagerInstance = nil;<br>static dispatch_once_t predicate;<br>dispatch_once(&amp;predicate, ^{<br>ManagerInstance = [[self alloc] init];<br>});<br>return ManagerInstance;<br>}<br>三、代码的优化</p>
</li>
</ul>
<p>通过上面的方法，我们已经可以使用类方法来得到这个单例，但很多时候，项目的工程量很大，还有可能会很多开发者同时参与一个项目的开发，为了安全与管理代码的方便，也为了给不是这个单例的创作者但会用到这个单例的开发人员一些提示，我们通常会重写一些方法：</p>
<p>首先我们自己实现一个alloc方法：</p>
<p>+(instancetype)myAlloc{<br>return [super allocWithZone:nil];<br>}<br>将我们的单例实现方法略作修改：</p>
<p>+(ZYHPayManager <em>)sharedMamager{<br>static ZYHPayManager </em> manager;<br>if (manager==nil) {<br>manager=[[ZYHPayManager myAlloc]init];<br>}<br>return manager;<br>}<br>将一些视图实例化对象的方法重写：</p>
<p>+(instancetype)alloc{<br>NSAssert(0, @”这是一个单例对象，请使用+(ZYHPayManager <em>)sharedMamager方法”);<br>return nil;<br>}<br>+(instancetype)allocWithZone:(struct _NSZone </em>)zone{<br>return [self alloc];<br>}<br>-(id)copy{<br>NSLog(@”这是一个单例对象，copy将不起任何作用”);<br>return self;<br>}<br>+(instancetype)new{<br>return  [self alloc];<br>}<br>注意：这里的alloc使用了断言，让任何视图通过alloc创建对象的程序段断在此处，给程序员提示。copy方法这里只是简单的返回了原对象，并未做任何处理，打印信息给程序员提示。</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/10/12/单例模式解读/">
    <time datetime="2015-10-12T06:23:27.000Z" class="entry-date">
        2015-10-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-菜鸟成神宝典" class="post-菜鸟成神宝典 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/10/01/菜鸟成神宝典/">菜鸟成神宝典</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/10/01/菜鸟成神宝典/" data-id="cipc8c2dx0009hxs6sz0tmc9s" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p></p><h1>菜鸟成神宝典</h1><p></p>
<p> （一）类与对象 <a href="http://blog.jobbole.com/79566/" target="_blank" rel="external">http://blog.jobbole.com/79566/</a><br><br>（二）成员变量和属性 <a href="http://blog.jobbole.com/79570/" target="_blank" rel="external">http://blog.jobbole.com/79570/</a><br><br>（三）消息和方法 <a href="http://blog.jobbole.com/79574/" target="_blank" rel="external">http://blog.jobbole.com/79574/</a><br><br>（四）Method Swizzling <a href="http://blog.jobbole.com/79580/" target="_blank" rel="external">http://blog.jobbole.com/79580/</a><br><br>（五）协议与分类 <a href="http://blog.jobbole.com/79583/" target="_blank" rel="external">http://blog.jobbole.com/79583/</a><br><br>（六）补充 <a href="http://blog.jobbole.com/79588/" target="_blank" rel="external">http://blog.jobbole.com/79588/</a><br><br><br><br>内存管理教程和原理剖析（一）<a href="http://blog.jobbole.com/66197/" target="_blank" rel="external">http://blog.jobbole.com/66197/</a><br><br>内存管理教程和原理剖析（二）<a href="http://blog.jobbole.com/66363/" target="_blank" rel="external">http://blog.jobbole.com/66363/</a><br><br>内存管理教程和原理剖析（三）<a href="http://blog.jobbole.com/66369/" target="_blank" rel="external">http://blog.jobbole.com/66369/</a><br><br>内存管理教程和原理剖析（四）<a href="http://blog.jobbole.com/66372/" target="_blank" rel="external">http://blog.jobbole.com/66372/</a><br><br>深浅拷贝 <a href="http://ios.jobbole.com/84859/" target="_blank" rel="external">http://ios.jobbole.com/84859/</a><br><br><br><br><br><br>10分钟 搞定JS和iOS的交互<br><br><br>你必须先看这篇文章： <a href="http://www.open-open.com/lib/view/open1419305655562.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1419305655562.html</a><br><br><a href="http://blog.csdn.net/lizhongfu2013/article/details/9232129" target="_blank" rel="external">http://blog.csdn.net/lizhongfu2013/article/details/9232129</a><br><br><a href="http://blog.csdn.net/lizhongfu2013/article/details/9236357" target="_blank" rel="external">http://blog.csdn.net/lizhongfu2013/article/details/9236357</a><br><br>干货好文章 <a href="http://www.jianshu.com/p/a329cd4a67ee" target="_blank" rel="external">http://www.jianshu.com/p/a329cd4a67ee</a><br><br>干货好文章 <a href="http://ios.jobbole.com/84491/" target="_blank" rel="external">http://ios.jobbole.com/84491/</a><br><br>交互范例 ：<a href="http://www.open-open.com/lib/view/open1463553967635.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1463553967635.html</a><br><br><a href="http://www.open-open.com/lib/view/open1456311816823.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1456311816823.html</a><br><br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/10/01/菜鸟成神宝典/">
    <time datetime="2015-09-30T17:13:03.000Z" class="entry-date">
        2015-10-01
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-如何做一个面霸" class="post-如何做一个面霸 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/09/24/如何做一个面霸/">如何做一个面霸</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/09/24/如何做一个面霸/" data-id="cipc8c2ds0008hxs6u7tanfx7" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p></p><h1>如何做一个面霸</h1><p></p>
<p></p><br><h2>风雨泽§万物苏</h2><br><p>1.<a href="http://www.open-open.com/lib/view/open1440165855942.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1440165855942.html</a> 面试大全从简单到复杂(简单篇)</p><br><p>2.<a href="http://zhangmingwei.iteye.com/blog/1748431" target="_blank" rel="external">http://zhangmingwei.iteye.com/blog/1748431</a> 史上最全的iOS面试题及答案<br></p><br><p>3.<a href="http://www.open-open.com/lib/view/open1460681498043.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1460681498043.html</a> 面试实战1</p><br><p>4.<a href="http://www.open-open.com/lib/view/open1460681420544.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1460681420544.html</a> 面试实战2</p><br><p>5.<a href="http://www.open-open.com/lib/view/open1460682694966.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1460682694966.html</a> 面试实战3<br></p><br><p>6.<a href="http://ios.jobbole.com/84919/" target="_blank" rel="external">http://ios.jobbole.com/84919/</a> runtime面试题看我你就足够了<br></p><br><p>7.<a href="http://www.open-open.com/lib/view/open1382923236124.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1382923236124.html</a> ios面试题汇总</p><br><p>8.<a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="external">https://github.com/ChenYilong/iOSInterviewQuestions</a> 太阳神的面试题，一个靠谱工程师必备宝典<br></p><br><p>9.<a href="http://www.open-open.com/lib/view/open1457952546563.html优酷的面试题" target="_blank" rel="external">http://www.open-open.com/lib/view/open1457952546563.html优酷的面试题</a></p><br><p>10.<a href="http://www.open-open.com/lib/view/open1456359620073.html宝库的面试题" target="_blank" rel="external">http://www.open-open.com/lib/view/open1456359620073.html宝库的面试题</a></p><br><p>11.<a href="http://www.open-open.com/lib/view/open1454028502198.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1454028502198.html</a> 多线程面试必看</p><br><p>12.<a href="http://www.cocoachina.com/programmer/20151019/13746.html" target="_blank" rel="external">http://www.cocoachina.com/programmer/20151019/13746.html</a> iOS综合面试题</p><br><p>13.<a href="http://www.90159.com/2015/07/26/71/" target="_blank" rel="external">http://www.90159.com/2015/07/26/71/</a> 程序员头条面试题集锦</p><br><p>14.<a href="http://www.henishuo.com/objective-c-base-interview/" target="_blank" rel="external">http://www.henishuo.com/objective-c-base-interview/</a> iOS笔试题<br></p><br><p>15.<a href="http://www.henishuo.com/ios-interview-entrance/" target="_blank" rel="external">http://www.henishuo.com/ios-interview-entrance/</a> 必看，必考面试大全<br></p><br><p>16.<a href="http://www.henishuo.com/nanjing-jingdong-interview/" target="_blank" rel="external">http://www.henishuo.com/nanjing-jingdong-interview/</a> 京东面试题</p>



      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/09/24/如何做一个面霸/">
    <time datetime="2015-09-24T07:01:56.000Z" class="entry-date">
        2015-09-24
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-collectionView" class="post-collectionView post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/06/24/collectionView/">collectionView</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/06/24/collectionView/" data-id="cipc8c2da0001hxs6kj3j99wk" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>iOS流布局UICollectionView系列六——将布局从平面应用到空间</p>
<h1>iOS流布局UICollectionView系列六——将布局从平面应用到空间</h1>

<p>先来实现一个炫酷的滚轮空间布局</p>
<p>万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout：</p>
<p>@interface MyLayout : UICollectionViewLayout</p>
<p>@end<br>对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。</p>
<p>至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。</p>
<p>在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码：</p>
<ul>
<li>(void)viewDidLoad {<br>[super viewDidLoad];<br>// Do any additional setup after loading the view, typically from a nib.<br>MyLayout <em> layout = [[MyLayout alloc]init];<br>UICollectionView </em> collect  = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout];<br>collect.delegate=self;<br>collect.dataSource=self;<br>[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@”cellid”];<br>[self.view addSubview:collect];<br>}</li>
</ul>
<p>-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView <em>)collectionView{<br>return 1;<br>}<br>-(NSInteger)collectionView:(UICollectionView </em>)collectionView numberOfItemsInSection:(NSInteger)section{<br>return 10;<br>}<br>-(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath{<br>UICollectionViewCell </em> cell  = [collectionView dequeueReusableCellWithReuseIdentifier:@”cellid” forIndexPath:indexPath];<br>cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];<br>UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)];<br>label.text = [NSString stringWithFormat:@”我是第%ld行”,(long)indexPath.row];<br>[cell.contentView addSubview:label];<br>return cell;<br>}<br>上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。</p>
<p>在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组：</p>
<p>-(NSArray<uicollectionviewlayoutattributes *=""> <em>)layoutAttributesForElementsInRect:(CGRect)rect{<br>NSMutableArray </em> attributes = [[NSMutableArray alloc]init];<br>//遍历设置每个item的布局属性<br>for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) {<br>[attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]];<br>}<br>return attributes;<br>}<br>之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法：</uicollectionviewlayoutattributes></p>
<p>-(UICollectionViewLayoutAttributes <em>)layoutAttributesForItemAtIndexPath:(NSIndexPath </em>)indexPath{<br>//创建一个item布局属性类<br>UICollectionViewLayoutAttributes <em> atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];<br>//获取item的个数<br>int itemCounts = (int)[self.collectionView numberOfItemsInSection:0];<br>//设置每个item的大小为260</em>100<br>atti.size = CGSizeMake(260, 100);<br>/*<br>后边介绍的代码添加在这里</p>
<p>*/<br>return atti;<br>}<br>上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。</p>
<p>首先，我们先将所有的item的位置都设置为collectionView的中心：</p>
<p>atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2);<br>这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下：</p>
<p>很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码:</p>
<p>//创建一个transform3D类<br>//CATransform3D是一个类似矩阵的结构体<br>//CATransform3DIdentity创建空得矩阵<br>CATransform3D trans3D = CATransform3DIdentity;<br>//这个值设置的是透视度，影响视觉离投影平面的距离<br>trans3D.m34 = -1/900.0;<br>//下面这些属性 后面会具体介绍<br>//这个是3D滚轮的半径<br>CGFloat radius = 50/tanf(M_PI<em>2/itemCounts/2);<br>//计算每个item应该旋转的角度<br>CGFloat angle = (float)(indexPath.row)/itemCounts</em>M_PI*2;<br>//这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加<br>//第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转<br>trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0);<br>//进行设置<br>atti.transform3D = trans3D;<br>对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下：</p>
<p>通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 </p>
<p>对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示：</p>
<p>每个item旋转的弧度就是其索引/(2*pi)。</p>
<p>通过上面的设置，我们再运行代码，效果如下：</p>
<p>仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下：</p>
<p>我们继续在刚才的代码后面添加这行代码：</p>
<p>//这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移<br>trans3D = CATransform3DTranslate(trans3D, 0, 0, radius);<br>再次运行，效果如下：</p>
<p>布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。</p>
<p>三、让滚轮滑动起来</p>
<p>通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果</p>
<p>首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域：</p>
<p>-(CGSize)collectionViewContentSize{<br>return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]);<br>}<br>这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法：</p>
<p>//返回yes，则一有变化就会刷新布局<br>-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds{<br>return YES;</p>
<p>}<br>将上面的布局的中心点设置加上一个动态的偏移量：</p>
<p>atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y);<br>现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理：</p>
<p>//获取当前的偏移量<br>float offset = self.collectionView.contentOffset.y;<br>//在角度设置上，添加一个偏移角度<br>float angleOffset = offset/self.collectionView.frame.size.height;<br>CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts<em>M_PI</em>2;<br>再看看效果，没错，就是这么简单，滚轮已经转了起来。</p>
<p>四、让其循环滚动的逻辑</p>
<p>我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下：</p>
<p>-(void)scrollViewDidScroll:(UIScrollView <em>)scrollView{<br>//小于半屏 则放到最后一屏多半屏<br>if (scrollView.contentOffset.y&lt;200) {<br>scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10</em>400);<br>//大于最后一屏多一屏 放回第一屏<br>}else if(scrollView.contentOffset.y&gt;11<em>400){<br>scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10</em>400);<br>}<br>}<br>因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配：</p>
<p>在viewController中：</p>
<p>//一开始将collectionView的偏移量设置为1屏的偏移量<br>collect.contentOffset = CGPointMake(0, 400);<br>在layout类中：</p>
<p>//将滚动范围设置为(item总数+2)<em>每屏高度<br>-(CGSize)collectionViewContentSize{<br>return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height</em>([self.collectionView numberOfItemsInSection:0]+2));<br>}<br>//将计算的具体item角度向前递推一个<br>CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts<em>M_PI</em>2;<br>OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/06/24/collectionView/">
    <time datetime="2015-06-23T20:21:26.000Z" class="entry-date">
        2015-06-24
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-runtime机制" class="post-runtime机制 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/06/12/runtime机制/">runtime机制</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/06/12/runtime机制/" data-id="cipc8c2di0005hxs67tq0evm1" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p></p><h1><br></h1><br>Runtime是一套底层的C语言API（包含强大的C语言数据类型和函数）<br>OC代码都是基于Runtime实现的，即编写的OC代码最终都会转成Runtime的代码，例如：<br>HCPerson *person = [HCPerson alloc] init];<br>[person setAge:10]; //这句会转换成objc_msgSend(person,@selector(setAge:),20);<br>Runtime的作用<br>获取类的私有变量<p></p>
<p>#import <objc runtime.h=""><br>// Ivar : 成员变量<br>unsigned int count = 0;<br>// 获得所有的成员变量<br>Ivar <em>ivars = class_copyIvarList([HCPerson class], &amp;count);<br>for (int i = 0; i&lt;count; i++) {<br>// 取得i位置的成员变量<br>Ivar ivar = ivars[i];<br>const char </em>name = ivar_getName(ivar);<br>const char *type = ivar_getTypeEncoding(ivar);<br>NSLog(@”%d %s %s”, i, name, type);</objc></p>
<p>}<br>动态产生类，成员变量和方法<br>动态修改类，成员变量和方法<br>对换两个方法的实现（swizzle）</p>
<p>例如：如果想要对iOS7以上和iOS7以下的图片进行适配，不同系统版本显示不同的图片，则可利用swizzle来实现<br>实现方法：<br>1.自定义UIImage的类imageWithName：方法，在该方法内进行系统版本号的判断，来显示不同的图片<br>2.将imageWithName:方法和系统的imageNamed:方法进行对换，这样，一旦调用系统的imageNamed:方法，便会执行自定义的imageWithName:方法，进行判断，显示不同的图片<br>/**</p>
<ul>
<li>只要分类被装载到内存中，就会调用1次<br>*/</li>
</ul>
<ul>
<li><p>(void)load<br>{<br>//获取类方法<br>Method otherMehtod = class_getClassMethod(self, @selector(imageWithName:));<br>Method originMehtod = class_getClassMethod(self, @selector(imageNamed:));<br>// 交换2个方法的实现<br>method_exchangeImplementations(otherMehtod, originMehtod);<br>}</p>
</li>
<li><p>(UIImage <em>)imageWithName:(NSString </em>)name<br>{<br>BOOL iOS7 = [[UIDevice currentDevice].systemVersion floatValue] &gt;= 7.0;<br>UIImage <em>image = nil;<br>if (iOS7) {<br>NSString </em>newName = [name stringByAppendingString:@”_os7”];<br>image = [UIImage imageWithName:newName];<br>}</p>
</li>
</ul>
<p>if (image == nil) {<br>image = [UIImage imageWithName:name];<br>}<br>return image;<br>}</p>
<p>文／冲破茧缚（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/20a02d17d6fc" target="_blank" rel="external">http://www.jianshu.com/p/20a02d17d6fc</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。<br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/06/12/runtime机制/">
    <time datetime="2015-06-12T05:45:08.000Z" class="entry-date">
        2015-06-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-SDWebImage的使用" class="post-SDWebImage的使用 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/11/12/SDWebImage的使用/">SDWebImage的使用</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/11/12/SDWebImage的使用/" data-id="cipc8c2d40000hxs6f1zn9m7s" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>第一步，下载SDWebImage，导入工程。github托管地址<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></span></p>
<p>第二步，在需要的地方导入头文件</p>
<p>1</p>
<p>#import “UIImageView+WebCache.h”<br>第三步，调用sd_setImageWithURL：方法缓存图片，注意，这就是新版本的新方法，旧方法是setImageWithURL:。下面将几个方法都介绍一下。</p>
<ol>
<li>sd_setImageWithURL：</li>
</ol>
<p>//图片缓存的基本代码，就是这么简单<br>[self.image1 sd_setImageWithURL:imagePath1];</p>
<ol>
<li>sd_setImageWithURL:  completed:</li>
</ol>
<p>//用block 可以在图片加载完成之后做些事情<br>[self.image2 sd_setImageWithURL:imagePath2 completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, NSURL *imageURL) {</p>
<p>NSLog(@”这里可以在图片加载完成之后做些事情”);</p>
<p>}];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:</li>
</ol>
<p>//给一张默认图片，先使用默认图片，当图片加载完成后再替换<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:  completed:</li>
</ol>
<p>//使用默认图片，而且用block 在完成后做一些事情<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”] completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, NSURL *imageURL) {</p>
<p>NSLog(@”图片加载完成后做的事情”);</p>
<p>}];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:  options:</li>
</ol>
<p>//options 选择方式</p>
<p>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”] options:SDWebImageRetryFailed];<br>其他就不一一介绍了，oc是自文档语言，看方法名就知道干什么的了。除了带options选项的方法，其他的方法都是综合存储，也就是内存缓存和磁盘缓存结合的方式，如果你只需要内存缓存，那么在options这里选择SDWebImageCacheMemoryOnly就可以了。</p>
<p>如果不想深入了解，到这里你已经可以用SDWebimage进行图片缓存了，接下来我要解释options的所有选项，以及SDWebImage内部执行流程。</p>
<p>一、options所有选项：</p>
<p>　　//失败后重试<br>SDWebImageRetryFailed = 1 &lt;&lt; 0,</p>
<p>//UI交互期间开始下载，导致延迟下载比如UIScrollView减速。<br>SDWebImageLowPriority = 1 &lt;&lt; 1,</p>
<p>//只进行内存缓存<br>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</p>
<p>//这个标志可以渐进式下载,显示的图像是逐步在下载<br>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</p>
<p>//刷新缓存<br>SDWebImageRefreshCached = 1 &lt;&lt; 4,</p>
<p>//后台下载<br>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</p>
<p>//NSMutableURLRequest.HTTPShouldHandleCookies = YES;</p>
<p>SDWebImageHandleCookies = 1 &lt;&lt; 6,</p>
<p>//允许使用无效的SSL证书<br>//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</p>
<p>//优先下载<br>SDWebImageHighPriority = 1 &lt;&lt; 8,</p>
<p>//延迟占位符<br>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</p>
<p>//改变动画形象<br>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,<br>二、SDWebImage内部实现过程</p>
<p>入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。<br>进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.<br>先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。<br>SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。<br>如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。<br>根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br>如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。<br>如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。<br>共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br>图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br>connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br>imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。<br>SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。<br>SDWebImagePrefetcher 可以预先下载图片，方便后续使用。<br>从上面流程可以看出，当你调用setImageWithURL:方法的时候，他会自动去给你干这么多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法：</p>
<p>//覆盖方法，指哪打哪，这个方法是下载imagePath2的时候响应<br>SDWebImageManager *manager = [SDWebImageManager sharedManager];</p>
<p>[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize) {</p>
<p>NSLog(@”显示当前进度”);</p>
<p>} completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {</p>
<p>NSLog(@”下载完成”);<br>}];<br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/11/12/SDWebImage的使用/">
    <time datetime="2014-11-12T06:31:40.000Z" class="entry-date">
        2014-11-12
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2016/06/12/ios视频直播开发/">ios视频直播开发</a>
          </li>
        
          <li>
            <a href="/2016/05/25/ios毛玻璃的实现/">ios毛玻璃的实现</a>
          </li>
        
          <li>
            <a href="/2016/05/25/音频直播的难点总结/">音频直播的难点总结</a>
          </li>
        
          <li>
            <a href="/2015/12/12/iosd多线程－－死锁/">iosd多线程－－死锁</a>
          </li>
        
          <li>
            <a href="/2015/10/12/单例模式解读/">单例模式解读</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2016 风
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>