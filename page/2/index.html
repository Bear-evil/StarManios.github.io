<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="美丽总是那么短暂" />
  

  
  
  
  
  
  
  <title>风士魁</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="美丽总是那么短暂">
<meta property="og:type" content="website">
<meta property="og:title" content="风士魁">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="风士魁">
<meta property="og:description" content="美丽总是那么短暂">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风士魁">
<meta name="twitter:description" content="美丽总是那么短暂">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="风士魁" rel="home">风士魁</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">走的太快容易孤独，快跟上我的步伐！！！</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-SDWebImage的使用" class="post-SDWebImage的使用 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/11/12/SDWebImage的使用/">SDWebImage的使用</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/11/12/SDWebImage的使用/" data-id="cipc8ea4y0003iis68vto88eo" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>第一步，下载SDWebImage，导入工程。github托管地址<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">https://github.com/rs/SDWebImage</a></span></p>
<p>第二步，在需要的地方导入头文件</p>
<p>1</p>
<p>#import “UIImageView+WebCache.h”<br>第三步，调用sd_setImageWithURL：方法缓存图片，注意，这就是新版本的新方法，旧方法是setImageWithURL:。下面将几个方法都介绍一下。</p>
<ol>
<li>sd_setImageWithURL：</li>
</ol>
<p>//图片缓存的基本代码，就是这么简单<br>[self.image1 sd_setImageWithURL:imagePath1];</p>
<ol>
<li>sd_setImageWithURL:  completed:</li>
</ol>
<p>//用block 可以在图片加载完成之后做些事情<br>[self.image2 sd_setImageWithURL:imagePath2 completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, NSURL *imageURL) {</p>
<p>NSLog(@”这里可以在图片加载完成之后做些事情”);</p>
<p>}];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:</li>
</ol>
<p>//给一张默认图片，先使用默认图片，当图片加载完成后再替换<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”]];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:  completed:</li>
</ol>
<p>//使用默认图片，而且用block 在完成后做一些事情<br>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”] completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, NSURL *imageURL) {</p>
<p>NSLog(@”图片加载完成后做的事情”);</p>
<p>}];</p>
<ol>
<li>sd_setImageWithURL:  placeholderImage:  options:</li>
</ol>
<p>//options 选择方式</p>
<p>[self.image1 sd_setImageWithURL:imagePath1 placeholderImage:[UIImage imageNamed:@”default”] options:SDWebImageRetryFailed];<br>其他就不一一介绍了，oc是自文档语言，看方法名就知道干什么的了。除了带options选项的方法，其他的方法都是综合存储，也就是内存缓存和磁盘缓存结合的方式，如果你只需要内存缓存，那么在options这里选择SDWebImageCacheMemoryOnly就可以了。</p>
<p>如果不想深入了解，到这里你已经可以用SDWebimage进行图片缓存了，接下来我要解释options的所有选项，以及SDWebImage内部执行流程。</p>
<p>一、options所有选项：</p>
<p>　　//失败后重试<br>SDWebImageRetryFailed = 1 &lt;&lt; 0,</p>
<p>//UI交互期间开始下载，导致延迟下载比如UIScrollView减速。<br>SDWebImageLowPriority = 1 &lt;&lt; 1,</p>
<p>//只进行内存缓存<br>SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</p>
<p>//这个标志可以渐进式下载,显示的图像是逐步在下载<br>SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</p>
<p>//刷新缓存<br>SDWebImageRefreshCached = 1 &lt;&lt; 4,</p>
<p>//后台下载<br>SDWebImageContinueInBackground = 1 &lt;&lt; 5,</p>
<p>//NSMutableURLRequest.HTTPShouldHandleCookies = YES;</p>
<p>SDWebImageHandleCookies = 1 &lt;&lt; 6,</p>
<p>//允许使用无效的SSL证书<br>//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</p>
<p>//优先下载<br>SDWebImageHighPriority = 1 &lt;&lt; 8,</p>
<p>//延迟占位符<br>SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</p>
<p>//改变动画形象<br>SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,<br>二、SDWebImage内部实现过程</p>
<p>入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。<br>进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.<br>先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。<br>SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片。<br>如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。<br>根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。<br>如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。<br>如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。<br>共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。<br>图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br>connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br>imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。<br>SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。<br>SDWebImagePrefetcher 可以预先下载图片，方便后续使用。<br>从上面流程可以看出，当你调用setImageWithURL:方法的时候，他会自动去给你干这么多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法：</p>
<p>//覆盖方法，指哪打哪，这个方法是下载imagePath2的时候响应<br>SDWebImageManager *manager = [SDWebImageManager sharedManager];</p>
<p>[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize) {</p>
<p>NSLog(@”显示当前进度”);</p>
<p>} completed:^(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {</p>
<p>NSLog(@”下载完成”);<br>}];<br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/11/12/SDWebImage的使用/">
    <time datetime="2014-11-12T06:31:40.000Z" class="entry-date">
        2014-11-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-页面跳转的方式" class="post-页面跳转的方式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/03/12/页面跳转的方式/">页面跳转的方式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/03/12/页面跳转的方式/" data-id="cipc8ea5s000diis6pv9ty48j" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>常用的就两种 一种通过导航，一种直接跳</span></p>
<p>第一种 直接跳转 思路大致就是new一个目的页面，然后设置下页面跳转动画 中间还可以做点目的页面的数据初始化:</p>
<p>ValueInputView *valueView = [[ValueInputView alloc] initWithNibName:@”ValueInputView”bundle:[NSBundle mainBundle]];</p>
<p>valueView.delegate = self;</p>
<p>[valueView setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</p>
<p>[self presentModalViewController:valueView animated:YES];</p>
<p>//返回 </p>
<p>[self dismissModalViewControllerAnimated:YES];</p>
<p>第二:</p>
<p>利用UINavigationController，调用pushViewController，进行跳转；这种采用压栈和出栈的方式，进行Controller的管理。调用popViewControllerAnimated方法可以返回</p>
<p>PickImageViewController *ickImageViewController = [[PickImageViewController alloc] init]; </p>
<p>[self.navigationController pushViewController: ickImageViewController animated:true]; </p>
<p>四种setModalTransitionStyle风格</p>
<p>UIModalTransitionStyleCoverVertical 从底部滑入<br>UIModalTransitionStyleFlipHorizontal,水平翻转进入<br>UIModalTransitionStyleCrossDissolve,交叉溶解<br>UIModalTransitionStylePartialCurl,翻页</p>
<p>场景切换</p>
<p>多个场景之间切换的样式(Style)总共有5个：<br>Modal(模态) – 过渡到另一个场景，以完成一项任务。任务完成后，将关闭该场景，并返回到原来的场景。<br>Push(压入) – 创建一个场景链，用户可在其中前后移动。用于导航视图控制器。<br>Replace(替换，仅适用于iPad) – 替换当前场景，用于一些iPad特有的视图控制器。<br>Popover(弹出框，仅适用于iPad) – 一个带箭头的弹出框。<br>Custome(自定义) – 通过编译在场景之间进行自定义过渡。</p>
<p>过渡类型(Transition)是从一个场景切换到另一个场景时播放的动画。有4个选项：<br>Cover Vertical – 新场景从下向上移动，逐渐覆盖旧场景。<br>Flip Horizontal – 视图水平翻转，以显示背面的新场景。<br>Cross Dissolve – 旧场景淡出，新场景淡入。<br>Partial Curl – 旧场景像书页一样翻开，显示下面的新场景。</p>
<p>在iPad应用程序中，还会多出一个Presentation属性，它决定了模态视图在屏幕上的显示方式。有4种显示样式：<br>Form Sheet(表单) – 将场景调整到比屏幕小(不管朝向)，并在当前场景后面显示原始场景，这几乎相当于在一个iPad窗口中显示。<br>Page Sheet(页面) – 调整场景大小，使其以纵向格式显示。<br>Full Screen(全屏) – 调整场景大小，使其覆盖整个屏幕。<br>Current Context(当前上下文) – 以原始场景的显示方式展示场景。</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/03/12/页面跳转的方式/">
    <time datetime="2014-03-11T17:26:58.000Z" class="entry-date">
        2014-03-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-页面传值的方式-1" class="post-页面传值的方式-1 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/03/12/页面传值的方式-1/">页面传值的方式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/03/12/页面传值的方式-1/" data-id="cipc8ea5i000aiis6r9t7z2tj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>属性传值 将A页面所拥有的信息通过属性传递到B页面使用</p>
<p>B页面定义了一个naviTitle属性，在A页面中直接通过属性赋值将A页面中的值传到B页面。</p>
<p>A页面DetailViewController.h文件</p>
<p>#import <uikit uikit.h=""></uikit></p>
<p>#import “DetailViewController.h”<br>@interface RootViewController :UIViewController<changedelegate><br>{<br>UITextField *tf;<br>}<br>@end</changedelegate></p>
<p>A RootViewController.m页面实现文件</p>
<p>#import “RootViewController.h”</p>
<p>#import “DetailViewController.h”</p>
<p>@interface RootViewController ()<br>@end<br>@implementation RootViewController<br>//核心代码<br>-(void)loadView<br>{<br>UIButton <em>btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];<br>btn.frame = CGRectMake(0, 0, 100, 30);<br>[btn setTitle:@”Push” forState:0];<br>[btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];<br>[self.view addSubview:btn];<br>}<br>-(void)pushAction:(id)sender<br>{<br>tf = (UITextField </em>)[self.viewviewWithTag:1000];<br>//导航push到下一个页面<br>//pushViewController 入栈引用计数+1，且控制权归系统</p>
<p>DetailViewController *detailViewController = [[DetailViewControlleralloc]init];<br>//属性传值，直接属性赋值<br>detailViewController.naviTitle =tf.text;<br>//导航push到下一个页面<br>[self.navigationControllerpushViewController:detailViewController animated:YES];<br>[detailViewControllerrelease];<br>}</p>
<p>B页面DetailViewController.h文件</p>
<p>#import <uikit uikit.h=""><br>@interface DetailViewController :UIViewController<br>{<br>UITextField <em>textField;<br>NSString </em>_naviTitle;<br>}<br>@property(nonatomic,retain)NSString *naviTitle;<br>@end</uikit></p>
<p>B页面.m实现文件</p>
<p>#import “DetailViewController.h”<br>@interface DetailViewController ()<br>@end<br>@implementation DetailViewController<br>@synthesize naviTitle =_naviTitle;<br>-(void)loadView<br>{<br>self.view = [[[UIViewalloc]initWithFrame:CGRectMake(0,0, 320,480)]autorelease];<br>self.title = self.naviTitle ;<br>}</p>
<p>代理传值<br>A页面push到B页面，如果B页面的信息想回传（回调）到A页面，用用代理传值，其中B定义协议和声明代理，A确认并实现代理，A作为B的代理<br>A页面RootViewController.h文件</p>
<p>#import <uikit uikit.h=""></uikit></p>
<p>#import “DetailViewController.h”<br>@interface RootViewController : UIViewController<changedelegate><br>{<br>UITextField *tf;<br>}<br>@end</changedelegate></p>
<p>A页面RootViewController.m实现文件</p>
<p>#import “RootViewController.h”</p>
<p>#import “DetailViewController.h”</p>
<p>@interface RootViewController ()<br>@end<br>@implementation RootViewController<br>//核心代码<br>-(void)loadView<br>{<br>UIButton <em>btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];<br>btn.frame = CGRectMake(0, 0, 100, 30);<br>[btn setTitle:@”Push” forState:0];<br>//A页面push到B页面<br>[btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];<br>[self.view addSubview:btn];<br>}<br>-(void)pushAction:(id)sender<br>{<br>tf = (UITextField </em>)[self.view viewWithTag:1000];<br>//导航push到下一个页面<br>//pushViewController 入栈引用计数+1，且控制权归系统<br>DetailViewController <em>detailViewController = [[DetailViewController alloc]init];<br>//代理传值<br>detailViewController.delegate =self;//让其自身作为代理人<br>//导航push到下一个页面<br>[self.navigationController pushViewController:detailViewController animated:YES];<br>[detailViewController release];<br>}<br>//实现代理方法<br>-(void)changeTitle:(NSString </em>)aStr<br>{<br>tf = (UITextField *)[self.view viewWithTag:1000];<br>tf.text = aStr;//将从B页面传入的参数赋给A页面中的TextField<br>tf.text = aStr;<br>}<br>B页面DetailViewController.m文件</p>
<p>#import <uikit uikit.h=""><br>@interface DetailViewController : UIViewController<br>{<br>UITextField <em>textField;<br>//定义代理<br>id<changedelegate>_delegate;<br>}<br>@property(nonatomic,assign)id<changedelegate> delegate;<br>@end<br>//定义协议<br>@protocol ChangeDelegate <nsobject><br>-(void)changeTitle:(NSString </nsobject></changedelegate></changedelegate></em>)aStr;//协议方法<br>@end</uikit></p>
<p>B页面DetailViewController.h实现文件</p>
<p>#import “DetailViewController.h”<br>@interface DetailViewController ()<br>@end<br>@implementation DetailViewController<br>-(void)loadView<br>{<br>self.view = [[[UIView alloc]initWithFrame:CGRectMake(0, 0, 320, 480)]autorelease];<br>UIBarButtonItem *doneItem = [[UIBarButtonItemalloc]initWithBarButtonSystemItem:UIBarButtonSystemItemDonetarget:selfaction:@selector(doneAction:)];<br>self.navigationItem.rightBarButtonItem = doneItem;<br>[doneItemrelease];<br>}<br>//pop回前一个页面<br>-(void)doneAction:(id)sender<br>{<br>if (self.delegate &amp;&amp; [self.delegaterespondsToSelector:@selector(changeTitle:)])//若代理存在且响应了changeTitle这个方法<br>{<br>//[self.delegate changeTitle:textField.text];<br>[self.delegatechangeTitle:textField.text];//将textField.text参数传给changeTitle方法  让代理，也就是A页面去实现这个方法<br>NSLog(@”%@”,self.navigationController.viewControllers);<br>[self.navigationControllerpopViewControllerAnimated:YES];<br>}<br>}</p>
<p>单例传值（实现共享）</p>
<p>AppStatus.h  创建一个单例类 AppStatus</p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>@interface AppStatus : NSObject<br>{<br>NSString <em>_contextStr;<br>}<br>@property(nonatomic,retain)NSString </em>contextStr;</p>
<p>+(AppStatus *)shareInstance;</p>
<p>@end</p>
<p>AppStatus.m  </p>
<p>#import “AppStatus.h”</p>
<p>@implementation AppStatus<br>@synthesize contextStr = _contextStr;</p>
<p>static AppStatus <em>_instance = nil;<br>+(AppStatus </em>)shareInstance<br>{<br>if (_instance == nil)<br>{<br>_instance = [[super alloc]init];<br>}<br>return _instance;<br>}</p>
<p>-(id)init<br>{<br>if (self = [super init])<br>{</p>
<p>}<br>return  self;<br>}</p>
<p>-(void)dealloc<br>{<br>[super dealloc];<br>}</p>
<p>@end</p>
<p>A页面RootViewController.h</p>
<p>#import “RootViewController.h”</p>
<p>#import “DetailViewController.h”</p>
<p>#import “AppStatus.h”</p>
<p>@interface RootViewController ()</p>
<p>@end</p>
<p>@implementation RootViewController<br>-(void)loadView<br>{<br>//核心代码<br>UIButton *btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];<br>btn.frame = CGRectMake(0, 0, 100, 30);<br>[btn setTitle:@”Push” forState:0];<br>[btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];<br>[self.view addSubview:btn];<br>}</p>
<p>-(void)pushAction:(id)sender<br>{</p>
<p>tf = (UITextField *)[self.view viewWithTag:1000];</p>
<p>//单例传值  将要传递的信息存入单例中（共享中）<br>//  [[AppStatus shareInstance]setContextStr:tf.text]; 跟下面这种写法是等价的<br>[AppStatus shareInstance].contextStr = tf.text;<br>//导航push到下一个页面<br>//pushViewController 入栈引用计数+1，且控制权归系统</p>
<p>DetailViewController *detailViewController = [[DetailViewController alloc]init];</p>
<p>//导航push到下一个页面<br>[self.navigationController pushViewController:detailViewController animated:YES];<br>[detailViewController release];<br>}<br>@end</p>
<p>B页面DetailViewController.h</p>
<p>#import <uikit uikit.h=""><br>@protocol ChangeDelegate;//通知编译器有此代理</uikit></p>
<p>@interface DetailViewController : UIViewController<br>{<br>UITextField *textField;<br>}<br>@end</p>
<p>B页面DetailViewController.m</p>
<p>#import “DetailViewController.h”</p>
<p>#import “AppStatus.h”</p>
<p>@interface DetailViewController ()</p>
<p>@end</p>
<p>@implementation DetailViewController<br>@synthesize naviTitle = _naviTitle;</p>
<p>-(void)loadView<br>{<br>self.view = [[[UIView alloc]initWithFrame:CGRectMake(0, 0, 320, 480)]autorelease];</p>
<p>//单例<br>self.title = [AppStatus shareInstance].contextStr;</p>
<p>textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 100, 150, 30)];<br>textField.borderStyle = UITextBorderStyleLine;<br>[self.view addSubview:textField];<br>[textField release];</p>
<p>UIBarButtonItem *doneItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDonetarget:self action:@selector(doneAction:)];<br>self.navigationItem.rightBarButtonItem = doneItem;<br>[doneItem release];</p>
<p>}</p>
<p>//这个方法是执行多遍的  相当于刷新view<br>-(void)viewWillAppear:(BOOL)animated<br>{<br>[super viewWillAppear:animated];</p>
<p>tf = (UITextField *)[self.view viewWithTag:1000];<br>tf.text = [AppStatus shareInstance].contextStr;</p>
<p>}<br>//pop回前一个页面<br>-(void)doneAction:(id)sender<br>{<br>//  单例传值<br>[AppStatus shareInstance].contextStr = textField.text;<br>[self.navigationController popToRootViewControllerAnimated:YES];<br>} </p>
<p>通知传值 谁要监听值的变化，谁就注册通知  特别要注意，通知的接受者必须存在这一先决条件</p>
<p>A页面RootViewController.h</p>
<p>#import <uikit uikit.h=""></uikit></p>
<p>#import “DetailViewController.h”</p>
<p>@interface RootViewController : UIViewController<changedelegate><br>{<br>UITextField *tf;<br>}<br>@end </changedelegate></p>
<p>A页面RootViewController.m</p>
<p>#import “IndexViewController.h”</p>
<p>#import “DetailViewController.h”</p>
<p>#import “AppStatus.h”</p>
<p>@implementation IndexViewController</p>
<p>-(void)dealloc<br>{<br>[[NSNotificationCenter defaultCenter] removeObserver:self<br>name:@”CHANGE_TITLE” object:nil];<br>[super dealloc];<br>}</p>
<p>-(id)init<br>{<br>if (self = [super init])<br>{<br>[[NSNotificationCenter defaultCenter] addObserver:self<br>selector:@selector(change:)<br>name:@”CHANGE_TITLE”<br>object:nil];<br>}<br>return self;<br>}</p>
<p>-(void)change:(NSNotification <em>)aNoti<br>{<br>// 通知传值<br>NSDictionary </em>dic = [aNoti userInfo];<br>NSString *str = [dic valueForKey:@”Info”];</p>
<p>UITextField <em>tf =  (UITextField </em>)[self.view viewWithTag:1000];<br>tf.text = str;<br>}</p>
<p>-(void)viewWillAppear:(BOOL)animated<br>{<br>[super viewWillAppear:animated];</p>
<p>/<em><br>// 单例传值<br>UITextField </em>tf =  (UITextField <em>)[self.view viewWithTag:1000];<br>tf.text = [AppStatus shareInstance].contextStr;
</em>/<br>}<br>@end</p>
<p>DetailViewController.h</p>
<p>#import <uikit uikit.h=""><br>@protocol ChangeDelegate;//通知编译器有此代理</uikit></p>
<p>@interface DetailViewController : UIViewController<br>{<br>UITextField *textField;<br>}<br>@end</p>
<p>DetailViewController.m</p>
<p>#import “DetailViewController.h”</p>
<p>#import “AppStatus.h”</p>
<p>@implementation DetailViewController<br>@synthesize naviTitle = _naviTitle;</p>
<p>-(void)loadView<br>{</p>
<p>UIBarButtonItem *doneItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDonetarget:self action:@selector(doneAction:)];<br>self.navigationItem.rightBarButtonItem = doneItem;<br>[doneItem release];<br>}<br>// pop回前一个页面<br>-(void)doneAction:(id)sender<br>{</p>
<p>NSDictionary *dic = [NSDictionary dictionaryWithObject:textField.text forKey:@”Info”];</p>
<p>[[NSNotificationCenter defaultCenter] postNotificationName:@”CHANGE_TITLE” object:nil userInfo:dic];</p>
<p>[self.navigationController popViewControllerAnimated:YES];</p>
<p>}</p>
<p>Block<br>几种形式的Block<br>//无返回值<br>void (^block1) (void);<br>block1 = ^{<br>NSLog(@”bock demo”);<br>};<br>block1();</p>
<p>//int返回类型<br>int (^block2) (void);<br>block2  = ^(void)<br>{<br>int a  = 1 ,b =1;<br>int c = a+b;<br>return  c;<br>};</p>
<p>//有返回 有参数<br>int (^block3)(int, int)= ^(int a, int b)<br>{<br>int c = a +b;<br>return c;</p>
<p>};<br>NSLog(@”bock=%d”,block3(1,2));</p>
<p>//有返回值，有参数并且可以修改block之外变量的block<br>static int sum = 10;// __blcik and static关键字 或者 _block int sum = 10<br>int (^block4) (int) =^(int a)<br>{<br>sum=11;<br>int c = sum+a;   //此时sum就是可以修改的了，若没加static或_block关键字则不能修改block之外变量<br>return c;<br>};<br>NSLog(@”block4= %d”,block4(4));</p>
<p>Block传值<br>例如A(Ablock)页面的值传道B(Bblock)页面  </p>
<p>在A页面中ABlock.h<br>@interface Ablock : UIViewController<uitableviewdelegate,uitableviewdatasource><br>{<br>UITableView <em>_tableview;<br>UILabel </em>labe;<br>UIImageView *imagevies;<br>}<br>@end</uitableviewdelegate,uitableviewdatasource></p>
<p>-(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath<br>{<br>[_tableview deselectRowAtIndexPath:indexPath animated:YES];</p>
<p>Bblcok <em>bblock = [[Bblcok alloc] initwithBlock:Block_copy(^(NSString </em>aBlock){<br>labe.text = aBlock;<br>NSLog(@”%@”,aBlock);</p>
<p>})];</p>
<p>bblock.imgeviews = imagevies.image;<br>bblock.String = labe.text;<br>[self.navigationController pushViewController:bblock animated:YES];<br>[bblock release];<br>}</p>
<p>在A页面中Bblock.h</p>
<p>#import <uikit uikit.h=""><br>typedef  void (^MyBlock) (NSString <em>);<br>@interface Bblcok : UIViewController<br>{<br>UIImageView </em>image;<br>UITextField <em>aField;<br>UIButton </em>aButt;<br>NSString <em>_String;<br>id _imgeviews;<br>MyBlock myBlock;<br>}<br>@property(nonatomic,copy)MyBlock myBlock;<br>@property(nonatomic,retain) id imgeviews;<br>@property(nonatomic,retain) NSString </em>String;<br>-(id)initwithBlock:(MyBlock)aBlcok;<br>@end</uikit></p>
<p>//<br>//  Bblcok.m<br>//  Blcok<br>//<br>//  Created by zhu  on 13-8-12.<br>//  Copyright (c) 2013年 Zhu Ji Fan. All rights reserved.<br>//</p>
<p>#import “Bblcok.h”</p>
<p>@interface Bblcok ()</p>
<p>@end</p>
<p>@implementation Bblcok<br>@synthesize imgeviews = _imgeviews , String = _String;<br>@synthesize myBlock = _myBlock;<br>-(id)initwithBlock:(MyBlock)aBlcok<br>{<br>if (self = [super init])<br>{<br>self.myBlock = aBlcok;<br>}<br>return self;<br>}</p>
<p>-(void) dealloc<br>{<br>[super dealloc];<br>}</p>
<p>-(void) loadView<br>{<br>UIControl *cont = [[UIControl alloc] initWithFrame:CGRectMake(0, 0, 320, 568-44)];<br>[cont addTarget:self action:@selector(Clcik) forControlEvents:UIControlEventTouchUpInside];<br>self.view = cont;</p>
<p>aField = [[UITextField alloc] initWithFrame:CGRectMake(60, 10, 160, 30)];<br>aField.borderStyle = UITextBorderStyleLine;<br>aField.placeholder = self.String;<br>[self.view addSubview:aField];</p>
<p>aButt = [UIButton buttonWithType:UIButtonTypeRoundedRect];<br>aButt.frame = CGRectMake(60, 50, 70, 30);<br>[aButt setTitle:@”修改” forState:0];<br>[aButt addTarget:self action:@selector(aButtClcik:) forControlEvents:UIControlEventTouchUpInside];<br>[self.view addSubview:aButt];</p>
<p>image = [[UIImageView alloc] initWithFrame:CGRectMake(60, 100, 210, 260)];<br>image.backgroundColor = [UIColor blueColor];<br>image.image = self.imgeviews;<br>[self.view addSubview:image];<br>[image release];</p>
<p>}</p>
<p>-(IBAction)aButtClcik:(id)sender<br>{<br>NSString *sting = aField.text;<br>myBlock(sting);<br>[self.navigationController popToRootViewControllerAnimated:YES];<br>}</p>
<p>-(void)Clcik<br>{<br>[aField resignFirstResponder];<br>}</p>
<ul>
<li><p>(void)viewDidLoad<br>{<br>[super viewDidLoad];<br>// Do any additional setup after loading the view.<br>}</p>
</li>
<li><p>(void)didReceiveMemoryWarning<br>{<br>[super didReceiveMemoryWarning];<br>// Dispose of any resources that can be recreated.<br>}</p>
</li>
</ul>
<p>@end<br></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/03/12/页面传值的方式-1/">
    <time datetime="2014-03-11T16:25:50.000Z" class="entry-date">
        2014-03-12
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-单例模式-1" class="post-单例模式-1 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/01/12/单例模式-1/">单例模式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/01/12/单例模式-1/" data-id="cipc8ea5p000ciis6yhu8of2h" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span><br>单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</span></p>
<p>1.单例模式的要点：</p>
<p>　　显然单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
<p>2.单例模式的优点：</p>
<p>　　1.实例控制：Singleton 会阻止其他对象实例化其自己的 Singleton 对象的副本，从而确保所有对象都访问唯一实例。<br>　　2.灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程</p>
<p>IOS中的单例模式<br>　　在objective-c中要实现一个单例类，至少需要做以下四个步骤：<br>　　1、为单例对象实现一个静态实例，并初始化，然后设置成nil，<br>　　2、实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，<br>　　3、重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，<br>　　4、适当实现allocWitheZone，copyWithZone，release和autorelease。<br>下面以SurveyRunTimeData为例子：</p>
<p>static SurveyRunTimeData *sharedObj = nil; //第一步：静态实例，并初始化。<br>@implementation SurveyRunTimeData</p>
<ul>
<li><p>(SurveyRunTimeData*) sharedInstance  //第二步：实例构造检查静态实例是否为nil<br>{<br>@synchronized (self)<br>{<br>if (sharedObj == nil)<br>{<br>[[self alloc] init];<br>}<br>}<br>return sharedObj;<br>}</p>
</li>
<li><p>(id) allocWithZone:(NSZone *)zone //第三步：重写allocWithZone方法<br>{<br>@synchronized (self) {<br>if (sharedObj == nil) {<br>sharedObj = [super allocWithZone:zone];<br>return sharedObj;<br>}<br>}<br>return nil;<br>}</p>
</li>
</ul>
<ul>
<li><p>(id) copyWithZone:(NSZone *)zone //第四步<br>{<br>return self;<br>}</p>
</li>
<li><p>(id) retain<br>{<br>return self;<br>}</p>
</li>
<li><p>(unsigned) retainCount<br>{<br>return UINT_MAX;<br>}</p>
</li>
<li><p>(oneway void) release<br>{</p>
</li>
</ul>
<p>}</p>
<ul>
<li><p>(id) autorelease<br>{<br>return self;<br>}</p>
</li>
<li><p>(id)init<br>{<br>@synchronized(self) {<br>[super init];//往往放一些要初始化的变量.<br>return self;<br>}<br>}</p>
</li>
</ul>
<p>@end</p>
<p><span></span></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/01/12/单例模式-1/">
    <time datetime="2014-01-11T20:20:20.000Z" class="entry-date">
        2014-01-12
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2016/06/12/nihao/">nihao</a>
          </li>
        
          <li>
            <a href="/2016/06/12/ios视频直播开发/">ios视频直播开发</a>
          </li>
        
          <li>
            <a href="/2016/05/25/ios毛玻璃的实现/">ios毛玻璃的实现</a>
          </li>
        
          <li>
            <a href="/2016/05/25/音频直播的难点总结/">音频直播的难点总结</a>
          </li>
        
          <li>
            <a href="/2015/12/12/iosd多线程－－死锁/">iosd多线程－－死锁</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2016 风
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>